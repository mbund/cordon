// Code generated by bpf2go; DO NOT EDIT.
//go:build (386 || amd64 || arm || arm64 || loong64 || mips64le || mipsle || ppc64le || riscv64 || wasm) && linux

package objs

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"
	"structs"

	"github.com/cilium/ebpf"
)

type BpfContextConnect struct {
	_       structs.HostLayout
	Lock    uint32
	_       [4]byte
	PidTgid uint64
	N       uint32
	Value   struct {
		_     structs.HostLayout
		Daddr uint32
		Dport uint16
		Proto uint16
	}
	_ [4]byte
}

type BpfContextFile struct {
	_       structs.HostLayout
	Lock    uint32
	_       [4]byte
	PidTgid uint64
	N       uint32
	Value   struct {
		_       structs.HostLayout
		Path    [4096]int8
		Accmode uint32
	}
}

type BpfContextMirror struct {
	_       structs.HostLayout
	Lock    uint32
	_       [4]byte
	PidTgid uint64
	N       uint32
	Value   uint32
}

type BpfContextSleep struct {
	_       structs.HostLayout
	Lock    uint32
	_       [4]byte
	PidTgid uint64
	N       uint32
	Value   uint32
}

type BpfCorrelationContext struct {
	_    structs.HostLayout
	Tgid uint32
	Pid  uint32
	Gid  uint32
	Uid  uint32
}

type BpfFilePolicy struct {
	_       structs.HostLayout
	I_ino   uint32
	S_dev   uint32
	Accmode uint32
}

type BpfOverlayCorrelation struct {
	_      structs.HostLayout
	Size   int64
	PtRegs struct {
		_      structs.HostLayout
		R15    uint64
		R14    uint64
		R13    uint64
		R12    uint64
		Bp     uint64
		Bx     uint64
		R11    uint64
		R10    uint64
		R9     uint64
		R8     uint64
		Ax     uint64
		Cx     uint64
		Dx     uint64
		Si     uint64
		Di     uint64
		OrigAx uint64
		Ip     uint64
		Cs     uint16
		_      [6]byte
		Flags  uint64
		Sp     uint64
		Ss     uint16
		_      [6]byte
	}
}

// LoadBpf returns the embedded CollectionSpec for Bpf.
func LoadBpf() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_BpfBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load Bpf: %w", err)
	}

	return spec, err
}

// LoadBpfObjects loads Bpf and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*BpfObjects
//	*BpfPrograms
//	*BpfMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func LoadBpfObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := LoadBpf()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// BpfSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type BpfSpecs struct {
	BpfProgramSpecs
	BpfMapSpecs
	BpfVariableSpecs
}

// BpfProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type BpfProgramSpecs struct {
	X64SysSetuid      *ebpf.ProgramSpec `ebpf:"__x64_sys_setuid"`
	BprmCheckSecurity *ebpf.ProgramSpec `ebpf:"bprm_check_security"`
	CredPrepare       *ebpf.ProgramSpec `ebpf:"cred_prepare"`
	FileOpen          *ebpf.ProgramSpec `ebpf:"file_open"`
	RestrictConnect   *ebpf.ProgramSpec `ebpf:"restrict_connect"`
	SocketBind        *ebpf.ProgramSpec `ebpf:"socket_bind"`
}

// BpfMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type BpfMapSpecs struct {
	CorrelationContexts   *ebpf.MapSpec `ebpf:"correlation_contexts"`
	FilePolicyMap         *ebpf.MapSpec `ebpf:"file_policy_map"`
	OverlayCorrelationMap *ebpf.MapSpec `ebpf:"overlay_correlation_map"`
	RequestArrayConnect   *ebpf.MapSpec `ebpf:"request_array_connect"`
	RequestArrayFile      *ebpf.MapSpec `ebpf:"request_array_file"`
	RequestArrayMirror    *ebpf.MapSpec `ebpf:"request_array_mirror"`
	RequestArraySleep     *ebpf.MapSpec `ebpf:"request_array_sleep"`
	ResponseArrayConnect  *ebpf.MapSpec `ebpf:"response_array_connect"`
	ResponseArrayFile     *ebpf.MapSpec `ebpf:"response_array_file"`
	ResponseArrayMirror   *ebpf.MapSpec `ebpf:"response_array_mirror"`
	ResponseArraySleep    *ebpf.MapSpec `ebpf:"response_array_sleep"`
}

// BpfVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type BpfVariableSpecs struct {
	CounterConnect *ebpf.VariableSpec `ebpf:"counter_connect"`
	CounterFile    *ebpf.VariableSpec `ebpf:"counter_file"`
	CounterMirror  *ebpf.VariableSpec `ebpf:"counter_mirror"`
	CounterSleep   *ebpf.VariableSpec `ebpf:"counter_sleep"`
	Pid            *ebpf.VariableSpec `ebpf:"pid"`
	TargetCgroup   *ebpf.VariableSpec `ebpf:"target_cgroup"`
}

// BpfObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to LoadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type BpfObjects struct {
	BpfPrograms
	BpfMaps
	BpfVariables
}

func (o *BpfObjects) Close() error {
	return _BpfClose(
		&o.BpfPrograms,
		&o.BpfMaps,
	)
}

// BpfMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to LoadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type BpfMaps struct {
	CorrelationContexts   *ebpf.Map `ebpf:"correlation_contexts"`
	FilePolicyMap         *ebpf.Map `ebpf:"file_policy_map"`
	OverlayCorrelationMap *ebpf.Map `ebpf:"overlay_correlation_map"`
	RequestArrayConnect   *ebpf.Map `ebpf:"request_array_connect"`
	RequestArrayFile      *ebpf.Map `ebpf:"request_array_file"`
	RequestArrayMirror    *ebpf.Map `ebpf:"request_array_mirror"`
	RequestArraySleep     *ebpf.Map `ebpf:"request_array_sleep"`
	ResponseArrayConnect  *ebpf.Map `ebpf:"response_array_connect"`
	ResponseArrayFile     *ebpf.Map `ebpf:"response_array_file"`
	ResponseArrayMirror   *ebpf.Map `ebpf:"response_array_mirror"`
	ResponseArraySleep    *ebpf.Map `ebpf:"response_array_sleep"`
}

func (m *BpfMaps) Close() error {
	return _BpfClose(
		m.CorrelationContexts,
		m.FilePolicyMap,
		m.OverlayCorrelationMap,
		m.RequestArrayConnect,
		m.RequestArrayFile,
		m.RequestArrayMirror,
		m.RequestArraySleep,
		m.ResponseArrayConnect,
		m.ResponseArrayFile,
		m.ResponseArrayMirror,
		m.ResponseArraySleep,
	)
}

// BpfVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to LoadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type BpfVariables struct {
	CounterConnect *ebpf.Variable `ebpf:"counter_connect"`
	CounterFile    *ebpf.Variable `ebpf:"counter_file"`
	CounterMirror  *ebpf.Variable `ebpf:"counter_mirror"`
	CounterSleep   *ebpf.Variable `ebpf:"counter_sleep"`
	Pid            *ebpf.Variable `ebpf:"pid"`
	TargetCgroup   *ebpf.Variable `ebpf:"target_cgroup"`
}

// BpfPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to LoadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type BpfPrograms struct {
	X64SysSetuid      *ebpf.Program `ebpf:"__x64_sys_setuid"`
	BprmCheckSecurity *ebpf.Program `ebpf:"bprm_check_security"`
	CredPrepare       *ebpf.Program `ebpf:"cred_prepare"`
	FileOpen          *ebpf.Program `ebpf:"file_open"`
	RestrictConnect   *ebpf.Program `ebpf:"restrict_connect"`
	SocketBind        *ebpf.Program `ebpf:"socket_bind"`
}

func (p *BpfPrograms) Close() error {
	return _BpfClose(
		p.X64SysSetuid,
		p.BprmCheckSecurity,
		p.CredPrepare,
		p.FileOpen,
		p.RestrictConnect,
		p.SocketBind,
	)
}

func _BpfClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed bpf_bpfel.o
var _BpfBytes []byte
